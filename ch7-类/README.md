类
==

## 定义抽象数据类型

类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程（以及设计）技术。

- 接口：用户所能执行的操作
- 实现
    1. 类的数据成员
    2. 负责接口实现的函数体
    3. 定义类所需的各种私有函数

注意：定义在类内部的函数是隐式的``inline``函数

## 访问控制与封装

- public：在整个程序内可被访问，用于定义类的接口
- private：可被类的成员函数访问，但是不能被使用该类的代码访问，封装（隐藏）了类的实现细节

一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。

### class和struct

默认访问权限不太一样

- struct：定义在第一个访问说明符之前的成员是``public``的
- class：定义在第一个访问说明符之前的成员是``private``的

### 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。

注意：友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制级别的约束。一般来说，最好在类定义开始或结束前的位置集中声明友元。

### 封装

- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

注意：尽管当类的定义发生改变时无须更改用户代码，但是使用了该类的源文件必须重新编译。

## 类的其他特性

### 类型成员

```cpp
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
```

通过类型别名来隐藏``string``对象

```cpp
// 使用类型别名等价地声明一个类型名字
using pos = std::string::size_type;
```

### 成员函数

```cpp
public:
    Screen() = default;
    Screen(pos ht, pos wd): height(ht), width(wd){}
```

因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认的构造函数。如果我们的类需要默认构造函数，必须显示地把它声明出来。

### 内联函数

定义在类内部的成员函数是自动``inline``的。最好只在类外部定义的地方说明``inline``，这样可以使类更容易理解。

### 重载成员函数

只要函数之间在参数的数量和/或类型上有所区别即可。

### 可变数据成员

一个可变数据成员（mutable data member）永远不会是``const``，即使它是``const``对象的成员。因此一个``const``成员函数可以改变一个可变成员的值。

通过在变量的声明中加入``mutable``关键字

```cpp
mutable size_t access_ctr;
```

### 类数据成员的初始值

类内初始值必须使用``=``的初始化形式或者花括号括起来的直接初始化形式

### 返回*this的成员函数



## 类的作用域

## 构造函数再探

## 类的静态成员
函数
====

## 函数基础

### 局部对象

名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见
- 对象的生命周期是程序执行过程中该对象存在的一段时间

在所有函数体之外定义的对象存在于程序的整个执行过程中，此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。

#### 自动对象

只存在于块执行期间的对象

- 函数形参
- 局部变量
    1. 如果变量定义本身含有初始值，则用该初始值进行初始化
    2. 否则执行默认初始化——产生未定义值

#### 局部静态对象

在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。在此期间，即使对象所在的函数结束执行也不会对它有影响。

### 函数声明

含有函数声明的头文件应该被包含在定义函数的源文件中

### 分离式编译

```bash
g++ main.cpp chapter6.cpp -o main

# or
g++ -c main.cpp # generate main.o
g++ -c chapter6.cpp # generate chapter6.o
g++ main.o chapter6.o -o main 
```

## 参数传递

1. 值传递：实参的值被拷贝到形参时，实参和形参是两个相互独立的对象
2. 引用传递：形参被绑定到对应的实参上

### 指针形参

熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，推荐使用引用类型的形参替代指针。

```cpp
void swap(int *i, int *j)
{
    int tmp = *i;
    *i = *j;
    *j = tmp;
}
```

### 引用形参

```cpp
void swap(int &i, int &j)
{
    int tmp = i;
    i = j;
    j = tmp;
}
```

如果函数无须改变引用形参的值，最好将其声明为常量引用

多返回值（隐式返回）：使用引用形参返回额外信息

注意：尽量使用常量引用

### 数组形参

两个特殊性质：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换为指针

```cpp
// 下面三种等价
void print(const int*);
void print(const int[]);
void print(const int[10]);
```

### 管理数组形参的三种技术

1. 使用标记指定数组长度
2. 使用标准库规范
3. 显示传递一个表示数组大小的形参

### 数组引用形参

```cpp
void print(int (&arr)[10]);
```

数组的维度限制了``print``函数的可用性，只能传递大小为10的数组

### 传递多维数组

```cpp
// 十个整数的数组的指针
void print(int (*matrix)[10], int rowSize);

// 等价定义
void print(int matrix[][10], int rowSize);
```

注意：

```cpp
// 10个指针构成的数组
int *matrix[10];

// 10个整数的数组的指针
int (*matrix)[10];
```

### 处理命令行选项

```cpp
int main(int argc, char *argv[])
```

- argc: 数组中字符串的数量
- argv: 是一个数组。指向C风格字符串的指针

### 含有可变参数的函数

- initializer_list
- 省略符形参：
    1. 用于C和C++通用的类型。特别注意，大多数类类型的对象在传递给省略符形参都无法正确拷贝。
    2. 只能出现在最后一个参数位置

## 返回类型和return语句

- 不要返回局部对象的引用和指针

### 引用返回左值

```cpp
char &get_val(string &str, string::size_type ix)
{
    return str[ix];
}
```

### 列表初始化返回值

```cpp
vector<string> getList()
{
    return {"aa", "bb", "cc", "dd", "ee"};
}
```

### 主函数main的返回值

- EXIT_SUCCESS
- EXIT_FAILURE

### 递归

如果一个函数调用了它自身，无论是直接还是间接的，都成为递归。

注意：main函数不能调用它自己

## 函数重载

```cpp
void print(int i);
void print(char *s);
void print(char *s, int size);
```

注意：main函数不能重载

### 重载确定

1. 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
2. 找不到任何一个函数与调用的实参匹配，此时编译器发出``无匹配``的错误信息。
3. 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时也发生错误，称为``二义性调用``

### 重载与作用域

在C++中，名字查找发生在类型检查之前

## 特殊用途语言特性

### 默认实参

1. 通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中
2. 局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。
3. 用作默认实参的名字在函数声明所在的作用域内解析


### 内联函数

调用函数的缺点

1. 调用函数比求等价表达式的值要慢一点
2. 在大多数机器上，一次调用函数包含一系列过程：
    1. 调用前要先保存寄存器，并在返回时恢复
    2. 可能需要拷贝实参
    3. 程序转向一个新的位置继续执行

在函数的返回类型前面使用``inline``关键字，即可声明成内联函数

一般来说，内联函数用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持``内联递归函数``

### constexpr函数

能用于常量表达式的函数

定义``constexpr``函数的规定：

1. 返回类型及所有形参的类型都必须是字面值类型
2. 函数体内必须有且只有一条``return``语句

注意：``constexpr``函数不一定返回常量表达式

## 调试帮助

预处理功能

- assert
- NDEBUG

### assert预处理宏

```cpp
assert(expr)
```

对expr求值，如果表达式返回假（即0），则输出信息并终止程序的执行；否则什么也不做。

### NDEBUG预处理变量

assert的行为依赖于一个叫``NDEBUG``的变量，如果定义了``NDEBUG``，则assert什么也不做。

可以通过下面的方式定义

1. define
2. 命令行选项

```cpp
void error_print()
{
#ifndef NDEBUG
    cerr << "ERROR: " << __FILE__
         << " : in function " << __func__
         << " at line " << __LINE__ << endl
         << " compiled on " __DATE__ << endl;
#endif
}
```

## 函数匹配

调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

## 函数指针

函数指针指向的是函数而非对象。

```cpp
// 比较两个字符串的长度
bool lengthCompare(const string &, const string &);

// 指向该函数的指针
bool (*p)(const string &, const string &);

// 错误写法：下面表示p是一个返回值为bool指针的函数
bool *p(const string &, const string &);
```

### 使用函数指针

```cpp
// 下面等价，取地址符可选
p = lengthCompare;
p = &lengthCompare;
```
